# let 和 const 命令

## 1.let 命令

### 基本用法 

用来声明变量，它的用法类似于var，但是所有声明的变量，只在let命令所在的代码块内有效。       

```
{
let a = 10;
var b = 1;
}

a //ReferenceError:a is not defined.
b //1

```

上面代码在代码块之中，分别用`let` 和 `var`声明了两个变量。然后在代码之外调用这两个变量，结果`let`声明的变量报错，`var`声明的变量返回了正确的值。说明`let`声明的变量只在它所在的代码块有效。     

```
var a = [];

for (var i = 0;i<10;i++){
  a[i] = function (){
    console.log(i);
  };
}

a[6](); //10




//全局变量，每次的循环 i 都会改变，直到最后一次为准：

var a = [];
for (var i = 0;i<18;i++){
  a[i] = function (){
    console.log(i);
  };
}
for (var i = 0;i<6;i++){
  a[i] = function (){
    console.log(i);
  };
}
a[2]();//6


虽然取的是 a[2];但是，由于是全局范围，实际上每一次的循环i 都改变了，最后的结果以循环的最后一次为准。
```

上面代码中，变量 i 是 var 命令声明的，在全局范围内都有效，所以全局只有一个变量 i 。每一次循环，变量 i 的值都会发生改变，而循环内被赋给数组 a 的函数内部的 `console.log(i)`，里面的 i 指向的就是全局的 i 。也就是说，所有数组 a 的成员里面的 i ,指向的都是同一个 i ，导致运行时输出的是最后一轮的 i 的值，也就是 10。     

如果使用 let，生命的变量仅在块级作用域内有效，最后输出的是6.   

```
var a = [];
for (let i = 0;i<10;i++){
  a[i] = function (){
    console.log(i);
  };
}

a[6]();//6

```

上面代码中，变量 i 是 let声明的，当前的 i 只在 本轮循环有效，所以每一次循环的 i 其实都是一个新的变量，所以最后输出的是 6。你可能会问，如果每一轮循环的变量 i 都是重新声明的，那它怎么知道上一轮的值？这是因为 javascript 引擎内部会记住上一轮的值，初始化本轮的变量 i 时，就在上一轮循环的基础上进行计算。     

另外， for 循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。       

```
for (let i = 0;i<3;i++){
  let i = 'abc';
  console.log(i);  
}

//abc
//abc
//abc
```

上面代码正确运行，输出3次abc。这表明函数内部的变量 i 与循环变量 i 不在同一个作用域，有各自单独的作用域。      

let 不存在变量提升，例如：   

```
//var 的情况
console.log(foo);//输出undefined
var foo = 2;

//let 的情况
console.log(bar); //报错ReferenceError
let bar = 2;
```

上面的代码，由于因为var 会发生变量的提升，也就是说 foo 已经存在了，但是没有值，输出时只是 undefined ，而没有报错。但是，let 声明的变量不会提升，所以输出时就会报错。       

`ES6明确规定，如果区域块中存在 let 和 const 命令，这个区块对这些命令生命的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。`     

总之，在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”。       

`let`不允许重复声明。     

### 为什么需要块级作用域？

ES5 只有全局作用域和函数作用域，没有块级作用域，这带来了很多不合理的场景。  

第一场景，内层变量可能会覆盖外层变量。      

```
var tmp = new Date();

function f(){
  console.log(tmp);
  if(false){
    var tmp = 'hello world';
  }
}

f();  //undefined

```

上面代码的意思是， if 代码块的外部使用外层的 tmp 变量，内部使用内层的 tmp  变量。但是，函数f执行后，输出结果为 undefined,原因在于变量提升，导致内层的 tmp 变量覆盖了外层的 tmp 变量。      

第二个场景，用来计数的循环变量泄露为全局变量。     

```
var s = 'hello';

for(var i =0;i<s.length;i++){
  console.log(s[i]);
}
console.log(i);//5

```

上面代码中，变量 i 只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。    


## const 命令



