# let 和 const 命令

## 1.let 命令

### 基本用法 

用来声明变量，它的用法类似于var，但是所有声明的变量，只在let命令所在的代码块内有效。       

```
{
let a = 10;
var b = 1;
}

a //ReferenceError:a is not defined.
b //1

```

上面代码在代码块之中，分别用`let` 和 `var`声明了两个变量。然后在代码之外调用这两个变量，结果`let`声明的变量报错，`var`声明的变量返回了正确的值。说明`let`声明的变量只在它所在的代码块有效。     

```
var a = [];

for (var i = 0;i<10;i++){
  a[i] = function (){
    console.log(i);
  };
}

a[6](); //10




//全局变量，每次的循环 i 都会改变，直到最后一次为准：

var a = [];
for (var i = 0;i<18;i++){
  a[i] = function (){
    console.log(i);
  };
}
for (var i = 0;i<6;i++){
  a[i] = function (){
    console.log(i);
  };
}
a[2]();//6


虽然取的是 a[2];但是，由于是全局范围，实际上每一次的循环i 都改变了，最后的结果以循环的最后一次为准。
```

上面代码中，变量 i 是 var 命令声明的，在全局范围内都有效，所以全局只有一个变量 i 。每一次循环，变量 i 的值都会发生改变，而循环内被赋给数组 a 的函数内部的 `console.log(i)`，里面的 i 指向的就是全局的 i 。也就是说，所有数组 a 的成员里面的 i ,指向的都是同一个 i ，导致运行时输出的是最后一轮的 i 的值，也就是 10。     

如果使用 let，生命的变量仅在块级作用域内有效，最后输出的是6.   

```
var a = [];
for (let i = 0;i<10;i++){
  a[i] = function (){
    console.log(i);
  };
}

a[6]();//6

```

上面代码中，变量 i 是 let声明的，当前的 i 只在 本轮循环有效，所以每一次循环的 i 其实都是一个新的变量，所以最后输出的是 6。你可能会问，如果每一轮循环的变量 i 都是重新声明的，那它怎么知道上一轮的值？这是因为 javascript 引擎内部会记住上一轮的值，初始化本轮的变量 i 时，就在上一轮循环的基础上进行计算。     

另外， for 循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。       

```
for (let i = 0;i<3;i++){
  let i = 'abc';
  console.log(i);  
}

//abc
//abc
//abc
```

上面代码正确运行，输出3次abc。这表明函数内部的变量 i 与循环变量 i 不在同一个作用域，有各自单独的作用域。      

let 不存在变量提升，例如：   

```
//var 的情况
console.log(foo);//输出undefined
var foo = 2;

//let 的情况
console.log(bar); //报错ReferenceError
let bar = 2;
```

上面的代码，由于因为var 会发生变量的提升，也就是说 foo 已经存在了，但是没有值，输出时只是 undefined ，而没有报错。但是，let 声明的变量不会提升，所以输出时就会报错。       

`ES6明确规定，如果区域块中存在 let 和 const 命令，这个区块对这些命令生命的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。`     

总之，在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”。       

`let`不允许重复声明。     

### 为什么需要块级作用域？

ES5 只有全局作用域和函数作用域，没有块级作用域，这带来了很多不合理的场景。  

第一场景，内层变量可能会覆盖外层变量。      

```
var tmp = new Date();

function f(){
  console.log(tmp);
  if(false){
    var tmp = 'hello world';
  }
}

f();  //undefined

```

上面代码的意思是， if 代码块的外部使用外层的 tmp 变量，内部使用内层的 tmp  变量。但是，函数f执行后，输出结果为 undefined,原因在于变量提升，导致内层的 tmp 变量覆盖了外层的 tmp 变量。      

第二个场景，用来计数的循环变量泄露为全局变量。     

```
var s = 'hello';

for(var i =0;i<s.length;i++){
  console.log(s[i]);
}
console.log(i);//5

```

上面代码中，变量 i 只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。    


## const 命令

### 基本用法

const 声明一个只读的常量。一旦声明，常量的值就不能改变。          

`const` 声明的变量不得改变值，这意味着，`const` 一旦声明变量，就必须立即初始化，不能留到以后赋值。      

```
const foo;//SyntaxError:Missing initializer in const declaration
```

上面代码表示，对于`const`来说，只声明不赋值，就会报错。       

`const`的作用域与`let`命令相同：只在声明所在的块级作用域内有效。     

### 本质

`const` 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据(数值、字符串、布尔值)，值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据(主要是对象和数组)，变量指向的内存地址，保存的只是一个指针，`const`只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对像声明为常量必须非常小心。     

### ES6 声明变量的六种方法 

ES5只有两种声明变量的方法：`var`命令和`function`命令。ES6除了添加`let`和`const`命令后面章节还会提到，另外两种声明变量的方法：`import`命令和`class`命令。 所以，ES6一共有6种声明变量的方法。    

### 4.顶层对象的属性

顶层对象，在浏览器环境指的是`window`对象，在Node指的是`global`对象。ES5之中，顶层对象的属性与全局变量是等价的。     
顶层对象的属性与全局变量挂钩，被认为是javaScript语言最大的设计败笔之一。这样的设计带来几个很大的问题。     
ES6为了改变这一点，一方面规定，为了保持兼容性，`var`命令和`function`命令声明的全局变量，依旧是顶层对象的属性。另一方面规定，`let`命令、`const`命令、`class`命令声明的全局变量，不属于顶层对象的属性，也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。    

### 5.global对象

ES5的顶层对象，本身也是一个问题，以为它在各个现实里面是不统一的。    

  - 浏览器里面，顶层对象是`window`，但 Node和 Web Worker 没有`window`。   

  - 浏览器和Web Worker 里面，`self`也指向顶层对象，但是Node没有`self`。  

  - Node 里面，顶层对象是`global`，但其他环境都不支持。     


同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是只用`this`变量，但是有局限性。   

  - 全局环境中，`this`会返回顶层对象，但是，Node 模块和ES6模块中，`this`返回的是当前模块。   

  - 函数里面的`this`，如果函数不是作为对象的方法运行，而是单纯作为函数运行，`this`会指向顶层对象。但是，严格模式下，这时`this`会返回`undefined`。   

  - 不管是严格模式，还是普通模式，`new Function('return this')()`,总是会返回全局对象。但是，如果浏览器用来CSP（Content Security Policy，内容安全政策），那么`eval`、`new Function`这些方法都可能无法使用。     

